# Java Native Interface

本质是一个运行时的动态链接，目前还不确定符号引用是延迟重定位还是直接全部重定位。

## 使用方式

1. 编写Java主方法

   ```JAVA
   package com.fmy;
   
   public class App {
       //有符号整数加法计算
       public native int add(int x,int y);
       public static void main(String[] args) throws Exception {
           System.load("/home/fanmingyang/JavaProjects/JNI/src/App.so");
           System.out.println("1 + 1 = " + new App().add(1, 1));
       }
   }
   ```

   

2. 编译字节码文件

   ```shell
   cd src
   javac  com/fmy/App.java
   ```

3. 生成c/c++头文件

   ```shell
   # JDK 8
   javah com.fmy.App
   
   # JDK 10
   javac -h ./ com/fmy/App.java
   ```

   头文件`com_fmy_App.h`内容：

   ```c
   /* DO NOT EDIT THIS FILE - it is machine generated */
   #include <jni.h>
   /* Header for class com_fmy_App */
   
   #ifndef _Included_com_fmy_App
   #define _Included_com_fmy_App
   #ifdef __cplusplus
   extern "C" {
   #endif
   /*
    * Class:     com_fmy_App
    * Method:    add
    * Signature: (II)I
    */
   JNIEXPORT jint JNICALL Java_com_fmy_App_add
     (JNIEnv *, jobject, jint, jint);
   
   #ifdef __cplusplus
   }
   #endif
   #endif
   
   ```

4. 编写c/c++函数实现`Java_com_fmy_App_add`

   ```c
   // App.c
   #include "com_fmy_App.h"
   
   JNIEXPORT jint JNICALL Java_com_fmy_App_add(JNIEnv * env, jobject jo, jint x, jint y){
       return x + y;
   }
   ```

5. 编译`App.c`为位置无关的共享目标`App.so`

   ```shell
   gcc -std=c11 -I /usr/lib/jvm/java-8-openjdk-amd64/include/ -I /usr/lib/jvm/java-8-openjdk-amd64/include/linux  -shared -fpic -o App.so App.c
   ```

6. 运行Java程序检查执行结果

   ```shell
   java com.fmy.App
   ```
   
   ```shell
   1 + 1 = 2
   ```
   
   
   
   
   
   